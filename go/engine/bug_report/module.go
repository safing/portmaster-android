package bug_report

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/textproto"
	"strings"
)

type PrivateBin struct {
	Urls struct {
		File []string
	}
}

type Section struct {
	Title string `json:"title"`
	Body  string `json:"body"`
}

type IssueRequest struct {
	Title        string    `json:"title"`
	Sections     []Section `json:"sections"`
	DebugInfoUrl string    `json:"debugInfoUrl"`
}

type TicketRequest struct {
	Title        string    `json:"title"`
	Sections     []Section `json:"sections"`
	RepoName     string    `json:"repoName"`
	Email        string    `json:"email"`
	DebugInfoUrl string    `json:"debugInfoUrl"`
}

// Upload text to private bin
func UploadToPrivateBin(file, content string) (string, error) {
	body := new(bytes.Buffer)
	writer := multipart.NewWriter(body)

	// Specific settings that the server requires.
	h := make(textproto.MIMEHeader)
	h.Set("Content-Disposition", fmt.Sprintf(`form-data; name="file"; filename="%s"`, file))
	h.Set("Content-Type", "text/plain")

	// Create the file part and write the content
	part, err := writer.CreatePart(h)
	if err != nil {
		return "", fmt.Errorf("failed to create part file: %s", err)
	}
	_, err = part.Write([]byte(content))
	if err != nil {
		return "", fmt.Errorf("failed to write content: %s", err)
	}

	err = writer.Close()
	if err != nil {
		return "", fmt.Errorf("failed to close writer: %s", err)
	}

	// Create th request
	httpRequest, err := http.NewRequest("POST", "https://support.safing.io/api/v1/upload", body)
	if err != nil {
		return "", fmt.Errorf("failed to create http request: %s", err)
	}

	// Set content type generated by the form writer
	httpRequest.Header.Set("content-type", writer.FormDataContentType())
	client := &http.Client{}

	// Send the request
	response, err := client.Do(httpRequest)
	if err != nil {
		return "", fmt.Errorf("http request failed: %s", err)
	}
	defer response.Body.Close()

	// Read body
	bodyContent, err := io.ReadAll(response.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %s", err)
	}

	// Check for error
	if response.StatusCode > 201 {
		return "", fmt.Errorf("server returned an error code: %d  %q", response.StatusCode, string(bodyContent))
	}

	// Parse and return
	bin := &PrivateBin{}
	err = json.Unmarshal(bodyContent, bin)
	if err != nil {
		return "", fmt.Errorf("failed to parse response response: %s", err)
	}

	return bin.Urls.File[0], nil
}

func CreateIssue(issueRequest *IssueRequest, repo string, preset string, genUrl bool) (string, error) {
	// repo := "portmaster-android"
	// preset := "report-bug.md"

	// Create request
	body, _ := json.Marshal(issueRequest)
	req, err := http.NewRequest("POST", fmt.Sprintf("https://support.safing.io/api/v1/issues/%s/%s", repo, preset), strings.NewReader(string(body)))
	if err != nil {
		return "", fmt.Errorf("failed to create request: %s", err)
	}

	// Setting generate-url will tell the server NOT to create the issue, but just generate a issue url, so the user can submit it.
	if genUrl {
		q := req.URL.Query()
		q.Add("generate-url", "")
		req.URL.RawQuery = q.Encode()
	}

	// Send the request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to send request: %s", err)
	}
	defer resp.Body.Close()

	// Read and parse
	respJson, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %s", err)
	}

	// Check for error
	if resp.StatusCode > 201 {
		return "", fmt.Errorf("server returned an error code: %d body: %q", resp.StatusCode, string(respJson))
	}

	respMap := make(map[string]string)
	err = json.Unmarshal(respJson, &respMap)
	if err != nil {
		return "", fmt.Errorf("failed to parse response: %s", err)
	}

	return respMap["url"], nil
}

func CreateTicket(ticketRequest *TicketRequest) error {
	// Create request
	body, _ := json.Marshal(ticketRequest)
	req, err := http.NewRequest("POST", "https://support.safing.io/api/v1/ticket", strings.NewReader(string(body)))
	if err != nil {
		return fmt.Errorf("failed to create request: %s", err)
	}

	// Send request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %s", err)
	}
	defer resp.Body.Close()

	return nil
}
