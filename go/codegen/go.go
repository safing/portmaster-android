package main

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
)

const goFileTemplate = `package exported 
import (
	"fmt"
	"encoding/json"

	"github.com/safing/portbase/log"
	"github.com/safing/portmaster-android/go/engine"
	"github.com/safing/portmaster-android/go/engine/ui"
)


// DO NOT EDIT THIS FILE!
// The file was autogenerated by go/codegenv2/gen.go

%s
`

const goFunctionTemplate = `func {{.Name}}(call engine.PluginCall) {
	// set up recovery
	defer func() {
		// recover from panic
		panicVal := recover()
		if panicVal != nil {
			log.Errorf("ui: function {{.Name}} panicked: %s", panicVal)
			if call != nil {
				call.Error(fmt.Sprintf("function panicked: %s", panicVal))
			}
		}
	}()

{{if .CreateProxy}}{{range .Params}}	// Parameter {{.Name}}
	{{.Name}}, err := call.{{get_type_func .Type}}("{{.Name}}")
	if err != nil {
		call.Error("missing {{.Name}} argument")
		return
	}
{{end}}	// Function call
	{{if len .ReturnTypes}}{{results .ReturnTypes}} := {{end}}ui.{{.Name}}({{params .Params}})
	{{range handle_errors .ReturnTypes}}
	if {{.}} != nil {
		call.Error({{.}}.Error())
		return
	}
	{{end}}
	{{range getSpecialReturnTypes .ReturnTypes}}{{.Name}}Json, _ := json.Marshal({{.Name}})
	{{end}}
{{if has_non_error_returns .ReturnTypes}}	// Resolve the call
	call.ResolveJson({{json_result .ReturnTypes}}){{else}}	// Resolve the call
	call.Resolve(){{end}}{{else}}	ui.{{.Name}}(call){{end}}
}

`

func printParamArray(vals []Val) string {
	var result string

	for i, val := range vals {
		if val.Name != "" {
			result += val.Name
		}

		if i != len(vals)-1 {
			result += ", "
		}
	}

	return result
}
func isSpecialType(returnType string) bool {
	switch returnType {
	case "int", "int32", "int64", "float32", "bool", "string":
		return false
	default:
		return true
	}
}

func getSpecialReturnTypes(returnTypes []string) []Val {
	var specialReturnTypes []Val

	for i, t := range getNoErrorTypes(returnTypes) {
		if isSpecialType(t) {
			val := Val{Name: fmt.Sprintf("ret%d", i), Type: t}
			specialReturnTypes = append(specialReturnTypes, val)
		}
	}
	return specialReturnTypes
}

func handleErrors(returnTypes []string) []string {
	var errorList []string
	for i, t := range returnTypes {
		if t == "error" {
			errorList = append(errorList, fmt.Sprintf("err%d", i))
		}
	}

	return errorList
}

func handleJsonResult(types []string) string {
	result := "fmt.Sprintf(`{"
	returnTypes := getNoErrorTypes(types)

	for i, t := range returnTypes {
		value := ""
		switch t {
		case "string":
			value = `"%s"`
		case "bool":
			value = "%t"
		case "int", "int32", "int64":
			value = "%d"
		case "float32":
			value = "%f"
		default:
			value = "%s"
		}
		result += fmt.Sprintf(`"ret%d": %s`, i, value)
		if i != len(returnTypes)-1 {
			result += ","
		}
	}

	result += "}`, "

	for i, t := range returnTypes {
		if isSpecialType(t) {
			result += fmt.Sprintf("ret%dJson", i)
		} else {
			result += fmt.Sprintf("ret%d", i)
		}
		if i != len(returnTypes)-1 {
			result += ", "
		}
	}

	result += ")"

	return result
}

func printResultArray(vals []string) string {
	var result string
	for i, val := range vals {
		if val != "error" {
			result += fmt.Sprintf("ret%d", i)
		} else {
			result += fmt.Sprintf("err%d", i)
		}

		if i != len(vals)-1 {
			result += ", "
		}
	}

	return result
}

func getTypeStringFunction(t string) string {
	switch t {
	case "string":
		return "GetString"
	case "int", "int32":
		return "GetInt"
	case "int64":
		return "GetLong"
	case "float32":
		return "GetFloat"
	case "bool":
		return "GetBool"
	}

	return "GetString"
}

func hasNonErrorReturnTypes(returnTypes []string) bool {
	for _, n := range returnTypes {
		if n != "error" {
			return true
		}
	}

	return false
}

func writeToGoFile(filename string, functions []Func) {
	goTmpl := template.New("GoFunctionTemplate")
	goTmpl.Funcs(template.FuncMap{
		"params":                printParamArray,
		"results":               printResultArray,
		"get_type_func":         getTypeStringFunction,
		"handle_errors":         handleErrors,
		"json_result":           handleJsonResult,
		"has_non_error_returns": hasNonErrorReturnTypes,
		"getSpecialReturnTypes": getSpecialReturnTypes,
	})
	_, err := goTmpl.Parse(goFunctionTemplate)
	if err != nil {
		fmt.Printf("Failed to parse template: %s", err)
		return
	}

	buf := new(bytes.Buffer)

	for _, r := range functions {
		goTmpl.Execute(buf, r)
	}

	goFile, err := os.Create(filename)
	if err != nil {
		fmt.Printf("Failed to create file: %s", err)
		return
	}
	defer goFile.Close()
	_, err = goFile.WriteString(fmt.Sprintf(goFileTemplate, buf.String()))
	if err != nil {
		fmt.Printf("Failed to write to file: %s", err)
		return
	}
}
